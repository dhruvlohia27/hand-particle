<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Hand Controlled 3D Particle System</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
  }
  video {
    display: none;
  }
</style>
</head>

<body>
<video id="video" autoplay playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ==========================
   THREE.JS SETUP
========================== */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ==========================
   PARTICLES
========================== */
const COUNT = 6000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);

for (let i = 0; i < COUNT; i++) {
  positions[i * 3]     = (Math.random() - 0.5) * 2;
  positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
  positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
}

geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

const material = new THREE.PointsMaterial({
  color: 0x3399ff,
  size: 0.025
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* ==========================
   SHAPES
========================== */
function heartShape(i, scale) {
  const t = (i / COUNT) * Math.PI * 2;
  return {
    x: scale * 0.16 * Math.pow(Math.sin(t), 3),
    y: scale * (
      0.13 * Math.cos(t) -
      0.05 * Math.cos(2 * t) -
      0.02 * Math.cos(3 * t) -
      0.01 * Math.cos(4 * t)
    ),
    z: 0
  };
}

function flowerShape(i, scale) {
  const t = (i / COUNT) * Math.PI * 2;
  const r = Math.sin(6 * t) * 0.4 + 1;
  return {
    x: scale * r * Math.cos(t),
    y: scale * r * Math.sin(t),
    z: 0
  };
}

/* ==========================
   MORPHING
========================== */
let targetShape = "heart";
let expansion = 1;

function updateParticles() {
  const pos = geometry.attributes.position.array;

  for (let i = 0; i < COUNT; i++) {
    const p =
      targetShape === "heart"
        ? heartShape(i, expansion)
        : flowerShape(i, expansion);

    pos[i * 3]     += (p.x - pos[i * 3]) * 0.05;
    pos[i * 3 + 1] += (p.y - pos[i * 3 + 1]) * 0.05;
    pos[i * 3 + 2] += (p.z - pos[i * 3 + 2]) * 0.05;
  }

  geometry.attributes.position.needsUpdate = true;
}

/* ==========================
   ANIMATION LOOP
========================== */
function animate() {
  requestAnimationFrame(animate);
  updateParticles();
  particles.rotation.y += 0.002;
  renderer.render(scene, camera);
}

animate();

/* ==========================
   RESIZE
========================== */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ==========================
   DEMO TOGGLE
========================== */
setInterval(() => {
  targetShape = targetShape === "heart" ? "flower" : "heart";
}, 4000);
</script>

</body>
</html>
